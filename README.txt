1. Syscall_GetPID- We made a static variable called lastpid which increments whenever we call getuniquePid. So whenever a thread is made, we assign it a pid which is the first after the last assigned pid. The first process is assigned pid 1.

2. Syscall_GetPPID- We made a global array in the system.cc file which stores the parent pid of each process. Whenever a new thread is created, this array is updated to the pid of the calling process except for the first process, for which we assigned the ppid 0.

3. Syscall_GetReg - For this, we used the function ReadRegister to read the contents of the register sent by the user and return it

4. Syscall_GetPA - We mimic the translate function for this process. From the virtual address which we received from the user, we calculate virtual page number by dividing it by the size of the page. The remainder of the division is the offset. Then we check the buffer(tlb). If it is empty, we get the data directly from the Translation Entry "NachosPageTable" which stores the physical page corresponding to each of its virtual page. Else we look for the virtual page number in the buffer and get physical page number from it. If the buffer is not empty but still it does not have an entry for that virtual page, we return -1. The physical address is then calculated by multiplying the physical page number by page size and adding the offset to it. 

5. Syscall_Time - For this, we returned the totalTicks variable from statistics class using the object stats.

6. Syscall_Yield - We just called the YieldCPU function 

7. Syscall_Sleep -We had to first create a sleep list for storing the list of threads presently asleep, sorted according to their wake-up time. We created a function wakeSomeSleepingThreads which is called at each timer interrupt. This function removes all the threads from the sleep list for which the time has exceeded the wake-up time and schedules them (moves them to ready list).
The call is implemented as follows. First, we set the interrupt status to off and calculate the present. If the time duration of time for which the thread is put to sleep is non-zero, we added the thread to sleep list setting the wake-up time equal to present time + duration of sleep, call putThreadToSleep and YieldCPU. Else we just call YieldCPU. The interrupt level is then reverted to the original

8. Syscall_NumInstr - We made a private variable in class Thread named instructionCount and made public functions IncrementInstructionCount and GetInstructionCount to update and query it. In the system call, we just query the instructioncount using the get function and return that to user

9. Syscall_exit - For this we made a global array to store the exit status of each process. On a successful exit, we update the exit status of the process. Also, a join call could have been waiting for this process's exit. To check that, FinishThread call was modified to check if the parent process of this process is in sleep state, waiting for it to exit. If so, then the parent is moved to the ready list. If this is the last running thread, the exit call must halt the machine. A count is maintained to check the number of running processes. If not then, the scheduler must schedule another thread. which is done in PutThreadToSleep routine called by FinishThread

10. Syscall_Join - To check that the Join has been called for a process that is a child of calling process, A PPID array is maintained.(The same array was used in Syscall_GetPPID.) Every element in the array stores the ppid of the process, whose pid is index of the element. Another array "exitStatus" stores the exit code of every process. All elements in array were initialized to -1. If the child process is already finished, the element in this array at the index equal to PID of child will store the exit status of child (always non-negative). If the element is positive, we return the exit status else we mark the corresponding child that its parent is waiting for its exit. This marking is implemented by a boolean array "ifJoinWithParent"(initialized to false). The element at index equal to child's PID is marked true and checked when the child executes exit call. This marking is accompanied by putting parent to sleep. The parent is not a member of sleep list or ready list while sleeping, and thus cannot be woken up by any interrupt. It is the responsibility of child upon exit to move the parent to the ready queue.

11 Syscall-Fork - Start by checking if enough memory is available for the address space of the child. Set interrupts to Off and Store the current interrupt status. Create a new address space (since, executable/filename is no longer available, a new ProcessAddrSpace constructor has been implemented and Used). If the address space can't be made, the syscall returns -1 to parent. The virtual page to physical page mapping has been done by using a variable "PhysPagesUsed" in Machine class. This variable is initialized to 0 and after every addrspace is allocated, it is incremented by the number of pages occupied by the new space in the memory. While mapping every virtual page numbe to physical page number, this variable is used. This mapping follows the rule: PhysicalPageNumber = virtualpagenumber+PhysPagesUsed. After this, the data from the parent's address space is copied to child's address space. A new thread object is constructed. The "CopyAddrSpace" routine has been added to ProcessAddrSpace class. Then, to copy the flags in NachOSPageTable entries, a seperate routine "CopyFlagsToPageTableNamed" has been added. This is followed by incrementing PC and writing 0 in return register and saving machine registers in child thread. Then the kernel stack is allocated using ThreadFork routine. ThreadFork routine is passed a ptr to function "CallOnFirstSchedule". The child executes this function when it's brought for execution in the machine for the first time. This function is responsible for deletion of any thread stored in "threadToBeDestroyed". And also copies the registers and pagetable reg from child's thread to machine. The parent is returned the PID of child.
