1. Syscall_GetReg - We use the machine's function 'ReadRegister' to read contents of the register number sent by the user and return them in Register 2.

2. Syscall_GetPA - We mimic the translate function for this process. From the virtual address which we received from the user, we calculate virtual page number by dividing it by the size of the page. The remainder of the division is the offset. Then we check the buffer(tlb). If it is empty, we get the data directly from the Translation Entry "NachosPageTable" which stores the physical page corresponding to each of its virtual page. Else we look for the virtual page number in the buffer and get physical page number from it. If the buffer is not empty but still it does not have an entry for that virtual page, we return -1. The physical address is then calculated by multiplying the physical page number by page size and adding the offset to it.

3. Syscall_GetPID - We made a static variable called lastpid which increments whenever we call getuniquePid. Whenever a thread is made, we assign it a pid equal to the current value of 'lastpid'. This lastpid is then incremented. This way, it is ensured that every incoming process gets assigned a unique PID, since the value of 'lastpid' will never come back to the old value for small number of processes.

4. Syscall_GetPPID - We made a global array in the system.cc file which stores the parent pid of each process. Whenever a new thread is created (using fork), we mark the parent of the newly created process as the PID of the process which called the fork syscall. The first process (pid == 1) is assigned a PPID of 0, since it was not created by another other process.

5. Syscall_Time - We return the totalTicks variable fromf statistics class using the object stats.

6. Syscall_Sleep - We first created a sleep list for storing the list of threads presently asleep, sorted according to their wake-up time. We create a function wakeSomeSleepingThreads which is called at each timer interrupt. This function removes all the threads from the sleep list for which the time has exceeded the wake-up time and schedules them (moves them to ready list).
The call is implemented as follows. First, we set the interrupt status to off and calculate the duration of the sleep requested. If the time duration of time for which the thread is put to sleep is non-zero, we added the thread to sleep list setting the wake-up time equal to present time + duration of sleep, call putThreadToSleep and YieldCPU. Else we just call YieldCPU. The interrupt level is then reverted to the original (so that when the thread is woken up again, the it sets the interrupt level back).

7. Syscall_Yield - We call the YieldCPU function provided for threads.

8. Syscall_Fork - Start by checking if enough memory is available for the address space of the child. Set interrupts to Off and store the current interrupt status. This is followed by creating a new address space (since, executable/filename is no longer available, a new ProcessAddrSpace constructor has been implemented and used). If the address space can't be made, the syscall returns -1 to parent. The virtual page to physical page mapping has been done by using a variable "PhysPagesUsed" in Machine class. This variable is initialized to 0 and after every addrspace allocation, it is incremented by the number of pages occupied by the new space in the memory. So it keeps track of the total physical pages used till now. While mapping virtual page numbers to physical page number, this variable is used. This mapping follows the rule: PhysicalPageNumber = virtualpagenumber+PhysPagesUsed (at the time of creation of the process). So each process gets a unique space in the physical memory, disjoint from other spaces. After this, the data from the parent's address space is copied to child's address space. A new thread object is constructed. The "CopyAddrSpace" routine has been added to ProcessAddrSpace class. Then, to copy the flags in NachOSPageTable entries, a seperate routine "CopyFlagsToPageTableNamed" has been added (this is necessary because the flags are a private member of the Address space class). Then the PC is incremented and 0 is written to the return register. This is the state which the child process now saves in it's saved context (so this is how it will see the registers when it wakes up). The kernel stack is allocated using ThreadFork routine. ThreadFork routine is passed a ptr to function "CallOnFirstSchedule". The child executes this function when it is brought for execution in the machine (only for the first time). This function is responsible for deletion of any thread stored in "threadToBeDestroyed". When inside this function, the child will also restore registers and pagetable reg from its saved user state. As for the parent, after the child's user state was saved, the parent updates the state such that the return register contains the PID of the new child. It then returns.


9. Syscall_Join - To check that the Join has been called for a process that is a child of calling process, a PPID array is maintained (The same array was used in Syscall_GetPPID). Every element in the array stores the PPID of the process with the PID equal to the element's index in the array. Another array "exitStatus" stores the exit code of every process. All elements in exitStatus array are initialized to -1. If the child process is already finished, the element in this array at the index equal to PID of child will store the exit status of child (always non-negative). If the element is positive, we return the exit status (there is no point in waiting). Else we mark for that child that its parent is waiting for its exit. This marking is implemented by a boolean array "ifJoinWithParent" (initialized to false). The element at index equal to child's PID is marked true and checked when the child executes exit call. This marking is accompanied by putting parent to sleep. The parent is not a member of sleep list or ready list while sleeping, and thus cannot be woken up by any interrupt. It is the responsibility of child upon exit to move the parent to the ready queue.

10. Syscall_Exec - We begin by turning off interrupts. We allocate a buffer of size 257 (more than the max executable name on UNIX), and read the name of the program to be run into that buffer. The executable is loaded as an OpenFile. If it did not exist or could not be loaded, an error of -1 is returned. Else, a new address space is allocated for that executable, and the executable file is closed. If there was an error while allocating the memory for the process, an error is returned. Else, the old address space is deleted, and a the new one is set as the current thread's address space. We follow this up by setting up the CPU registers for this thread, and updating the page table values in the machine. The interrupt is restored, and we return to the thread's execution, but with the new executable's instructions.

11. Syscall_Exit - We have a global array to store the exit status of each process. On a successful exit, we update the exit status of the process. Also, a join call could have been waiting for this process's exit. To check that, FinishThread call was modified to check if the parent process of this process is in sleep state, waiting for it to exit. If so, then the parent is moved to the ready list. If this is the last running thread, the exit call must halt the machine. A count is maintained to check the number of running processes. If not then, the scheduler must schedule another thread, which is done in "PutThreadToSleep" routine called by FinishThread.

12. Syscall_NumInstr - We made a private variable in class Thread named instructionCount and made public functions IncrementInstructionCount and GetInstructionCount to update and query it. In the system call, we query instructionCount using the GetInstructionCount function and return that to user.
